<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2000-01-01">

<title>Getting Started</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="gettingstarted_files/libs/clipboard/clipboard.min.js"></script>
<script src="gettingstarted_files/libs/quarto-html/quarto.js"></script>
<script src="gettingstarted_files/libs/quarto-html/popper.min.js"></script>
<script src="gettingstarted_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="gettingstarted_files/libs/quarto-html/anchor.min.js"></script>
<link href="gettingstarted_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="gettingstarted_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="gettingstarted_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="gettingstarted_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="gettingstarted_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Getting Started</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 1, 2000</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!--
# Put above to hide navigation (left), toc (right) or footer (bottom)

hide:
  - navigation 
  - toc
  - footer 

# You should hide the navigation if there are no subsections
# You should hide the Table of Contents if there are no important titles
-->
<section id="getting-started" class="level1">
<h1>Getting Started</h1>
<p>!!! note “Section Overview”</p>
<pre><code>&amp;#128368; **Time Estimation:** 10 minutes

&amp;#128172; **Learning Objectives:**    
    1. Launch the Proteomics Sandbox App and become proficient in using it for proteomics data analysis.  
    2. Familiarize oneself with the software tools available within the app, such as FragPipe, MaxQuant, PDV, SearchGUI, and PeptideShaker.  
    3. Develop skills in utilizing the Proteomics Sandbox App's lightweight clone feature, in order to reduce storage requirements while analyzing large datasets.  </code></pre>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The Proteomics Sandbox App is an excellent resource for biomedical students and non-computational researchers to learn and apply clinical proteomics. It provides a stable platform for proteomics software tools and offers a user-friendly interface. It is easy to use and does not require extensive coding knowledge. Furthermore, the app’s lightweight clone feature optimizes storage requirements when working with datasets.</p>
<section id="software" class="level3">
<h3 class="anchored" data-anchor-id="software">Software</h3>
<p>The software available in the Proteomics Sandbox includes <a href="https://fragpipe.nesvilab.org/">FragPipe</a>, <a href="https://www.maxquant.org/">MaxQuant</a>, <a href="https://github.com/wenbostar/PDV">PDV</a>, <a href="https://compomics.github.io/projects/searchgui.html">SearchGUI</a>, <a href="https://github.com/compomics/ThermoRawFileParser">ThermoRawFileParser</a>, <a href="https://compomics.github.io/projects/peptide-shaker.html">PeptideShaker</a>, <a href="https://mzmine.github.io/">MZmine 3</a>, and <a href="https://github.com/vdemichev/DiaNN">DIA-NN</a>. These software tools provide automated peptide and protein identification and quantification, comprehensive proteomics data analysis, visualization tools for spectral matches, a user-friendly interface for performing peptide searches, and a tool for visualizing and analyzing peptide search results. An overview table with a short description of each software tool is listed below for reference.</p>
<table class="table">
<thead>
<tr class="header">
<th>Software</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://fragpipe.nesvilab.org/">FragPipe</a></td>
<td>Automated peptide and protein identification and quantification using the MSFragger search engine. Supports the identification of arbitrary PTMs. Includes additional tools for post-processing and visualization of search results.</td>
</tr>
<tr class="even">
<td><a href="https://www.maxquant.org/">MaxQuant</a></td>
<td>Comprehensive software suite for proteomics data analysis. Includes protein and peptide identification, quantification, and visualization of spectral matches. Features an advanced search engine; only the command-line tool is available on Linux as the GUI is incompatible.</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/wenbostar/PDV">PDV</a></td>
<td>Visualization tool for spectral matches, particularly those obtained from MSFragger searches. Allows users to inspect and evaluate the quality of the matches. Supports annotation and customization of plots.</td>
</tr>
<tr class="even">
<td><a href="https://compomics.github.io/projects/searchgui.html">SearchGUI</a></td>
<td>User-friendly interface for performing peptide searches using multiple search engines (e.g., MSFragger, X!Tandem, OMSSA). Supports a wide range of search options and post-processing features.</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/compomics/ThermoRawFileParser">ThermoRawFileParser</a></td>
<td>A tool for converting Thermo Scientific RAW files to an open format mzML file that can be read by other proteomics software. Includes options for filtering, peak picking, and data conversion.</td>
</tr>
<tr class="even">
<td><a href="https://compomics.github.io/projects/peptide-shaker.html">PeptideShaker</a></td>
<td>Tool for visualizing and analyzing the results of peptide searches performed with SearchGUI. Includes features for filtering, annotation, and visualization of results. Supports integration with other proteomics databases and software.</td>
</tr>
<tr class="odd">
<td><a href="https://mzmine.github.io/">MZmine 3</a></td>
<td>Open-source software for LC-MS data processing, MZmine 3 is a complete redesign of the original MZmine toolbox. It offers a flexible, user-friendly platform with modules for the full LC-MS data analysis workflow.</td>
</tr>
<tr class="even">
<td><a href="https://github.com/vdemichev/DiaNN">DIA-NN</a></td>
<td>DIA-NN is a universal tool for DIA proteomics data. It features robust algorithms for reliable, large-scale experiments, emphasizing ease of use, reproducibility, and high throughput, processing up to 1000 runs per hour.</td>
</tr>
<tr class="odd">
<td><a href="https://www.ks.uiuc.edu/Research/vmd/">VMD</a></td>
<td>Visual Molecular Dynamics (VMD) is a molecular visualization program for displaying, animating, and analyzing large biomolecular systems using 3D graphics and built-in scripting. Supports various molecular dynamics simulations and bioinformatics analyses.</td>
</tr>
</tbody>
</table>
</section>
<section id="efficient-and-user-friendly-proteomics-software-access" class="level3">
<h3 class="anchored" data-anchor-id="efficient-and-user-friendly-proteomics-software-access">Efficient and User-Friendly Proteomics Software Access</h3>
<p>!!! tip “Advantages of using the Proteomics Sandbox App” 1. Access to stable proteomics software tools. 2. User-friendly interface that does not require extensive coding knowledge. 3. Lightweight clone feature that optimizes storage requirements when working with datasets.</p>
<p>The Clinical Proteomics Sandbox is an excellent resource for biomedical students and non-computational researchers seeking to expand their knowledge and skills in clinical proteomics.</p>
</section>
</section>
<section id="future-plans" class="level2">
<h2 class="anchored" data-anchor-id="future-plans">Future Plans</h2>
<p>The Clinical Proteomics Sandbox is constantly evolving to provide an accessible platform for learning and practicing clinical proteomics data analysis. In the future, the sandbox will expand its content to include new modules such as:</p>
<ul>
<li>Protein quantification and analysis of post-translational modifications, which will provide an even more comprehensive resource for those interested in clinical proteomics.</li>
<li>Introducing mass-spectrometry imaging (MSi) for clinical specimen. Data for MS imaging is available and public clinical datasets could also be included.</li>
<li>Generate course material based on clinical proteomics data using FragPipe.</li>
<li>Investigate protein complexes.</li>
</ul>
<p>In addition, the sandbox aims to:</p>
<ul>
<li>Make clinical proteomics data available for education and training purposes, offering students and researchers the opportunity to work with real-world clinical data and gain practical experience in analyzing and interpreting such data.</li>
<li>Move into statistical and functional analysis of quantitative proteomics data and meta-analysis of clinical proteomics data.</li>
</ul>
<p>As the sandbox continues to evolve, it will offer an invaluable resource for those seeking to enhance their knowledge and skills in clinical proteomics data analysis.</p>
</section>
<section id="in-brief" class="level2">
<h2 class="anchored" data-anchor-id="in-brief">In Brief</h2>
<p>The Clinical Proteomics Sandbox App provides a stable platform for proteomics software tools and a user-friendly interface for non-computational researchers and biomedical students to learn and apply clinical proteomics. The app’s lightweight clone feature optimizes storage requirements when working with datasets. Software tools available include <a href="https://fragpipe.nesvilab.org/">FragPipe</a>, <a href="https://www.maxquant.org/">MaxQuant</a>, <a href="https://github.com/wenbostar/PDV">PDV</a>, <a href="https://compomics.github.io/projects/searchgui.html">SearchGUI</a>, <a href="https://github.com/compomics/ThermoRawFileParser">ThermoRawFileParser</a>, and <a href="https://compomics.github.io/projects/peptide-shaker.html">PeptideShaker</a>. The Sandbox will expand its content in the future, including modules for protein quantification and analysis of post-translational modifications, and will make clinical proteomics data available for education and training purposes.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>